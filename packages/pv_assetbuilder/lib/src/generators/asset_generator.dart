/// Code generator for creating Dart asset classes with custom signature support
// ignore_for_file: avoid_print

library;

import '../scanner/asset_scanner.dart';
import '../config/config_parser.dart';
import '../resolvers/method_resolver.dart';
import '../utils/utils.dart';

/// Generates Dart code for asset access with custom signatures
class AssetGenerator {
  final PVAssetBuilderConfig config;
  final MethodResolver methodResolver;
  final String projectRoot;

  AssetGenerator(this.config, this.methodResolver, this.projectRoot);

  /// Generate complete Dart file content for assets
  Future<String> generateAssetFile(AssetDirectory rootDirectory) async {
    final buffer = StringBuffer();

    // File header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by pv_assetbuilder');
    buffer.writeln(
      "// ignore_for_file: unused_field, non_constantidentifier_names, camel_case_types, non_constant_identifier_names",
    );

    // Add package forwarding comment if enabled
    if (config.shouldForwardToPackage) {
      buffer.writeln('//');
      buffer.writeln('// ðŸ“¦ PACKAGE FORWARDING ENABLED');
      buffer.writeln(
        '// All asset paths are automatically prefixed with "packages/${config.currentPackageName}/"',
      );
      buffer.writeln(
        '// This allows other packages to access these assets via the Flutter package system',
      );
    }

    buffer.writeln();

    // Imports
    buffer.writeln("import 'package:pv_assetprovider/lib.dart';");

    // Add method imports for custom loaders
    if (config.signatures.hasCustomSignatures) {
      final methodImports = await _generateMethodImports();
      for (final import in methodImports) {
        buffer.writeln(import);
      }
      buffer.writeln();
    }

    // Generate classes for all directories (including nested ones)
    final allDirectories = _getAllDirectories(rootDirectory);

    for (final directory in allDirectories) {
      final classCode = _generateFolderClass(directory);
      buffer.writeln(classCode);
      buffer.writeln();
    }

    // Generate main AssetMap class with direct access
    buffer.writeln(_generateMainAssetClass(rootDirectory));
    buffer.writeln();

    // Generate final instance for direct access
    buffer.writeln('final IAssetMap AssetMap = IAssetMap();');
    buffer.writeln();

    // Generate initialization method that overrides LazyObjectConfig
    buffer.writeln(_generateInitializationMethod());

    return buffer.toString();
  }

  /// Generate class for a specific folder
  String _generateFolderClass(AssetDirectory directory) {
    final buffer = StringBuffer();
    final className = directory.anonymousClassName;

    // Extend PVAssetProvider if provider is true, otherwise PVAssetMap
    final baseClass = directory.generateProvider
        ? 'PVAssetProvider'
        : 'PVAssetMap';

    if (directory.generateProvider) {
      buffer.writeln('class $className extends $baseClass {');
      // Call parent constructor with path, applying package prefix if needed
      final providerPath = config.shouldForwardToPackage
          ? '${config.packagePrefix}${directory.relativePath}'
          : directory.relativePath;
      buffer.writeln(
        '  $className() : super("${_escapeStringForDart(providerPath)}");',
      );
    } else {
      buffer.writeln('class $className extends $baseClass {');
    }

    // Generate references to immediate subdirectories
    for (final subdir in directory.subdirectories) {
      final subdirClassName = subdir.anonymousClassName;
      final subdirInstance = _generateFieldName(subdir.relativePath);
      buffer.writeln(
        '  final $subdirClassName $subdirInstance = $subdirClassName();',
      );
    }

    // Add space between subdirs and assets if both exist
    if (directory.subdirectories.isNotEmpty &&
        directory.generateObjectMap &&
        directory.assets.isNotEmpty) {
      buffer.writeln();
    }

    // Generate LazyObject instances ONLY if generateObjectMap is true
    if (directory.generateObjectMap) {
      for (final asset in directory.assets) {
        final assetName = _getAssetNameFromFileName(asset.relativePath);

        // Construct the full asset path by combining directory path with asset filename
        // directory.relativePath is like "assets/config", asset.relativePath is like "app.json"
        final fullAssetPath = directory.relativePath.isEmpty
            ? asset.relativePath
            : '${directory.relativePath}/${asset.relativePath}';

        // Apply package prefix if forward_to_package is enabled
        final finalAssetPath = config.shouldForwardToPackage
            ? '${config.packagePrefix}$fullAssetPath'
            : fullAssetPath;

        // Check if asset needs loadSignature based on custom signature
        if (asset.needsLoadSignature && asset.signature != null) {
          buffer.writeln(
            '  final LazyObject $assetName = '
            'LazyObject("${_escapeStringForDart(finalAssetPath)}", loadSignature: "${asset.signature}");',
          );
        } else {
          buffer.writeln(
            '  final LazyObject $assetName = '
            'LazyObject("${_escapeStringForDart(finalAssetPath)}");',
          );
        }
      }
    }

    buffer.writeln('}');
    return buffer.toString();
  }

  /// Generate readable class name from directory path (deprecated - keeping for compatibility)
  String _generateReadableClassName(String relativePath) {
    if (relativePath.isEmpty) return 'RootAssets';

    // Split path and create meaningful class name
    final parts = relativePath
        .split('/')
        .where((part) => part.isNotEmpty)
        .toList();
    final className = parts.map((part) => _toPascalCase(part)).join('');

    return '${className}Assets';
  }

  /// Generate field name for subdirectory access
  String _generateFieldName(String relativePath) {
    if (relativePath.isEmpty) return 'root';

    // Get the last part of the path for the field name
    final parts = relativePath
        .split('/')
        .where((part) => part.isNotEmpty)
        .toList();
    return _toCamelCase(parts.last);
  }

  /// Convert to PascalCase for class names
  String _toPascalCase(String input) {
    return input
        .replaceAll(RegExp(r'[^a-zA-Z0-9]'), '_')
        .split('_')
        .where((part) => part.isNotEmpty)
        .map((part) => part[0].toUpperCase() + part.substring(1).toLowerCase())
        .join('');
  }

  /// Convert to camelCase for field names
  String _toCamelCase(String input) {
    final parts = input
        .replaceAll(RegExp(r'[^a-zA-Z0-9]'), '_')
        .split('_')
        .where((part) => part.isNotEmpty)
        .toList();

    if (parts.isEmpty) return 'field';

    final result =
        parts.first.toLowerCase() +
        parts
            .skip(1)
            .map(
              (part) => part[0].toUpperCase() + part.substring(1).toLowerCase(),
            )
            .join('');

    return result;
  }

  /// Get all directories recursively with deduplication
  List<AssetDirectory> _getAllDirectories(AssetDirectory root) {
    final directories = <AssetDirectory>[];
    final seen = <String>{};

    void collectDirectories(AssetDirectory dir) {
      // Skip if we've already seen this directory path
      if (seen.contains(dir.relativePath)) return;

      directories.add(dir);
      seen.add(dir.relativePath);

      for (final subdir in dir.subdirectories) {
        collectDirectories(subdir);
      }
    }

    // Collect all subdirectories (not the root itself)
    for (final subdir in root.subdirectories) {
      collectDirectories(subdir);
    }

    return directories;
  }

  /// Get clean asset name from file path
  String _getAssetNameFromFileName(String assetPath) {
    final fileName = assetPath.split('/').last;
    return fileName
        .replaceAll('.', '_')
        .replaceAll('-', '_')
        .replaceAll(' ', '_')
        .replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
  }

  /// Generate the main AssetMap class with direct folder access and deduplication
  String _generateMainAssetClass(AssetDirectory rootDirectory) {
    final buffer = StringBuffer();

    buffer.writeln('class IAssetMap extends PVAssetMap {');

    // Generate direct access properties for each top-level directory with deduplication
    final addedFields = <String>{};

    for (final directory in rootDirectory.subdirectories) {
      final className = directory.anonymousClassName;
      final fieldName = _generateFieldName(directory.relativePath);

      // Skip if we've already added this field name
      if (addedFields.contains(fieldName)) continue;

      buffer.writeln('  final $className $fieldName = $className();');
      addedFields.add(fieldName);
    }

    buffer.writeln('}');
    return buffer.toString();
  }

  /// Generate initialization method that overrides LazyObjectConfig
  String _generateInitializationMethod() {
    final buffer = StringBuffer();

    buffer.writeln('/// Initialize PV Asset System');
    buffer.writeln(
      '/// Call this method once before using any assets to override default loaders',
    );
    buffer.writeln('void initializePVAssets() {');

    if (config.signatures.hasCustomSignatures) {
      buffer.writeln('  // Override LazyObjectConfig with custom loaders');
      buffer.writeln();

      // Generate type map overrides
      bool hasTypeMaps = false;
      for (final signature in config.signatures.signatures.values) {
        if (signature.matchConfig?.extensions != null) {
          if (!hasTypeMaps) {
            buffer.writeln('  // Add custom type mappings');
            hasTypeMaps = true;
          }
          final extensions = signature.matchConfig!.extensions!
              .map((e) => "'$e'")
              .join(', ');
          buffer.writeln(
            '  LazyObjectConfig.defaultTypeMaps["${signature.name}"] = [$extensions];',
          );
        }
      }

      if (hasTypeMaps) {
        buffer.writeln();
      }

      // Generate loader overrides
      bool hasLoaders = false;
      for (final signature in config.signatures.signatures.values) {
        if (signature.loader != null) {
          if (!hasLoaders) {
            buffer.writeln('  // Add custom loaders');
            hasLoaders = true;
          }

          // Use MethodReference file and method properties with alias
          final loader = signature.loader!;
          final alias = PathResolver.generateImportAlias(loader.file);
          buffer.writeln(
            '  LazyObjectConfig.defaultTypeLoaders["${signature.name}"] = $alias.${loader.method};',
          );
        }
      }
    } else {
      buffer.writeln('  // No custom loaders configured');
      buffer.writeln('  // Using default LazyObjectConfig settings');
    }

    buffer.writeln('}');
    return buffer.toString();
  }

  /// Generate method imports for custom loaders using smart path resolution
  Future<List<String>> _generateMethodImports() async {
    final imports = <String>[];
    final importedFiles = <String>{};
    final pathResolver = PathResolver(projectRoot, config.target);

    // Collect unique file names from signature loaders
    for (final signature in config.signatures.signatures.values) {
      if (signature.loader != null) {
        final fileName = signature.loader!.file;
        if (!importedFiles.contains(fileName)) {
          final resolvedPath = await pathResolver.resolveLoaderPath(fileName);
          if (resolvedPath != null) {
            final alias = PathResolver.generateImportAlias(fileName);
            imports.add("import '$resolvedPath' as $alias;");
            importedFiles.add(fileName);
          } else {
            // Fallback or warning for missing loader
            imports.add(
              "// Warning: Could not resolve loader file: $fileName.dart",
            );
          }
        }
      }
    }

    return imports;
  }

  /// Generate README documentation for the generated assets
  String generateDocumentation(
    AssetDirectory rootDirectory,
    ScanStatistics stats,
  ) {
    final buffer = StringBuffer();

    buffer.writeln('# Generated Asset Documentation');
    buffer.writeln();
    buffer.writeln(
      'This file contains generated asset mappings for your project.',
    );
    buffer.writeln();

    buffer.writeln('## Statistics');
    buffer.writeln('- **Total Assets**: ${stats.totalAssets}');
    buffer.writeln('- **Total Directories**: ${stats.totalDirectories}');
    buffer.writeln();

    if (stats.signatureCount.isNotEmpty) {
      buffer.writeln('## Assets by Signature');
      for (final entry in stats.signatureCount.entries) {
        buffer.writeln('- **${entry.key}**: ${entry.value} assets');
      }
      buffer.writeln();
    }

    buffer.writeln('## Usage Examples');
    buffer.writeln();

    // Generate usage examples
    for (final directory in rootDirectory.subdirectories) {
      if (directory.assets.isNotEmpty) {
        final exampleAsset = directory.assets.first;
        buffer.writeln('```dart');
        buffer.writeln('// Access asset: ${exampleAsset.relativePath}');

        if (exampleAsset.needsLoadSignature && exampleAsset.signature != null) {
          buffer.writeln(
            'Widget widget = AssetMap.${_generateFieldName(directory.relativePath)}.${exampleAsset.dartIdentifier}.value;',
          );
          buffer.writeln(
            '// Uses custom loader for signature: ${exampleAsset.signature}',
          );
        } else {
          buffer.writeln(
            'Widget widget = AssetMap.${_generateFieldName(directory.relativePath)}.${exampleAsset.dartIdentifier}.value;',
          );
        }

        buffer.writeln('```');
        buffer.writeln();
        break;
      }
    }

    if (config.signatures.hasCustomSignatures) {
      buffer.writeln('## Custom Signatures');
      buffer.writeln();
      buffer.writeln('This project uses custom asset loading signatures:');

      for (final signature in config.signatures.signatures.values) {
        buffer.writeln('- **${signature.name}**: ');
        if (signature.loader != null) {
          buffer.writeln('  - Loader: `${signature.loader}`');
        }
        if (signature.matchConfig != null) {
          final match = signature.matchConfig!;
          if (match.pathPattern != null) {
            buffer.writeln('  - Path Pattern: `${match.pathPattern}`');
          }
          if (match.extensions != null) {
            buffer.writeln('  - Extensions: ${match.extensions}');
          }
          if (match.customMatcher != null) {
            buffer.writeln('  - Custom Matcher: `${match.customMatcher}`');
          }
        }
      }
      buffer.writeln();
    }

    return buffer.toString();
  }

  /// Convert string to valid Dart identifier
  String _toDartIdentifier(String input) {
    // Remove or replace invalid characters
    String identifier = input
        .replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_')
        .replaceAll(RegExp(r'^[0-9]'), '_');

    // Ensure it's not empty and starts with letter/underscore
    if (identifier.isEmpty || RegExp(r'^[0-9]').hasMatch(identifier)) {
      identifier = '_$identifier';
    }

    return identifier;
  }

  /// Escape string for use in Dart string literals
  String _escapeStringForDart(String input) {
    // Normalize path separators to forward slashes
    String normalized = input.replaceAll('\\', '/');

    // Escape special characters for Dart string literals
    return normalized
        .replaceAll('\\', '\\\\')
        .replaceAll('"', '\\"')
        .replaceAll('\$', '\\\$')
        .replaceAll('\n', '\\n')
        .replaceAll('\r', '\\r')
        .replaceAll('\t', '\\t');
  }

  /// Validate generated code for common issues
  List<String> validateGeneratedCode(AssetDirectory rootDirectory) {
    final errors = <String>[];

    // Check for duplicate identifiers within each directory scope
    void checkDirectory(AssetDirectory directory) {
      final localIdentifiers = <String>{};

      // Check for duplicates within this directory only
      for (final asset in directory.assets) {
        final id = asset.dartIdentifier;
        if (localIdentifiers.contains(id)) {
          errors.add(
            'Duplicate identifier within ${directory.relativePath}: $id (from ${asset.relativePath})',
          );
        } else {
          localIdentifiers.add(id);
        }
      }

      // Check for reserved Dart keywords within this directory
      const reservedWords = [
        'class',
        'const',
        'final',
        'var',
        'void',
        'return',
        'if',
        'else',
        'for',
        'while',
        'do',
        'switch',
        'case',
        'default',
        'break',
        'continue',
        'function',
        'import',
        'export',
        'library',
        'part',
        'abstract',
        'extends',
        'implements',
        'with',
        'super',
        'this',
        'null',
        'true',
        'false',
      ];

      for (final word in reservedWords) {
        if (localIdentifiers.contains(word)) {
          errors.add(
            'Reserved keyword used as identifier in ${directory.relativePath}: $word',
          );
        }
      }

      // Recursively check subdirectories
      for (final subdir in directory.subdirectories) {
        checkDirectory(subdir);
      }
    }

    checkDirectory(rootDirectory);
    return errors;
  }
}
