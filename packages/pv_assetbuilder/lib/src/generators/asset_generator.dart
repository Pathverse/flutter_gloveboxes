/// Code generator for creating Dart asset classes with custom signature support
// ignore_for_file: avoid_print

library;

import '../scanner/asset_scanner.dart';
import '../config/config_parser.dart';
import '../resolvers/method_resolver.dart';
import '../utils/utils.dart';

/// Generates Dart code for asset access with custom signatures
class AssetGenerator {
  final PVAssetBuilderConfig config;
  final MethodResolver methodResolver;
  final String projectRoot;

  AssetGenerator(this.config, this.methodResolver, this.projectRoot);

  /// Generate complete Dart file content for assets
  Future<String> generateAssetFile(AssetDirectory rootDirectory) async {
    final buffer = StringBuffer();

    // File header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by pv_assetbuilder');
    buffer.writeln();

    // Imports
    buffer.writeln("import 'package:pv_assetprovider/lib.dart';");

    // Add method imports for custom loaders
    if (config.signatures.hasCustomSignatures) {
      final methodImports = await _generateMethodImports();
      for (final import in methodImports) {
        buffer.writeln(import);
      }
      buffer.writeln();
    }

    // Generate classes for all directories (including nested ones)
    final allDirectories = _getAllDirectories(rootDirectory);
    final generatedClasses = <String>[];

    for (final directory in allDirectories) {
      final classCode = _generateFolderClass(directory);
      buffer.writeln(classCode);
      buffer.writeln();
      generatedClasses.add(directory.anonymousClassName);
    }

    // Generate main AssetMap class
    buffer.writeln(_generateMainAssetClass(rootDirectory, generatedClasses));
    buffer.writeln();

    // Generate initialization method that overrides LazyObjectConfig
    buffer.writeln(_generateInitializationMethod());

    return buffer.toString();
  }

  /// Generate class for a specific folder
  String _generateFolderClass(AssetDirectory directory) {
    final buffer = StringBuffer();
    final className = directory.anonymousClassName;

    // Extend PVAssetProvider if provider is true, otherwise PVAssetMap
    final baseClass = directory.generateProvider
        ? 'PVAssetProvider'
        : 'PVAssetMap';

    if (directory.generateProvider) {
      buffer.writeln('class $className extends $baseClass {');
      // Call parent constructor with path
      buffer.writeln(
        '  $className() : super("${_escapeStringForDart(directory.relativePath)}");',
      );
    } else {
      buffer.writeln('class $className extends $baseClass {');
    }

    // No need for separate provider - it's now inherited if generateProvider is true

    // Generate static references to immediate subdirectories
    for (final subdir in directory.subdirectories) {
      final subdirInstance = _toDartIdentifier(
        subdir.relativePath.split('/').last,
      );
      buffer.writeln(
        '  static final ${subdir.anonymousClassName} $subdirInstance = ${subdir.anonymousClassName}();',
      );
    }

    // Add space between subdirs and assets if both exist
    if (directory.subdirectories.isNotEmpty &&
        directory.generateObjectMap &&
        directory.assets.isNotEmpty) {
      buffer.writeln();
    }

    // Generate LazyObject instances ONLY if generateObjectMap is true
    if (directory.generateObjectMap) {
      for (final asset in directory.assets) {
        final assetName = _getAssetNameFromFileName(asset.relativePath);

        // Always generate without loadSignature - custom loading handled by runtime initialization
        buffer.writeln(
          '  static final LazyObject $assetName = '
          'LazyObject("${_escapeStringForDart(asset.relativePath)}");',
        );
      }
    }

    buffer.writeln('}');
    return buffer.toString();
  }

  /// Get all directories recursively
  List<AssetDirectory> _getAllDirectories(AssetDirectory root) {
    final directories = <AssetDirectory>[];

    void collectDirectories(AssetDirectory dir) {
      directories.add(dir);
      for (final subdir in dir.subdirectories) {
        collectDirectories(subdir);
      }
    }

    // Collect all subdirectories (not the root itself)
    for (final subdir in root.subdirectories) {
      collectDirectories(subdir);
    }

    return directories;
  }

  /// Get clean asset name from file path
  String _getAssetNameFromFileName(String assetPath) {
    final fileName = assetPath.split('/').last;
    return fileName
        .replaceAll('.', '_')
        .replaceAll('-', '_')
        .replaceAll(' ', '_')
        .replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
  }

  /// Get class name for directory
  String _getClassNameForDirectory(
    AssetDirectory directory, {
    bool isNested = false,
  }) {
    if (directory.relativePath.isEmpty) return 'Assets';

    final parts = directory.relativePath.split('/');
    final folderName = parts.last;

    // Capitalize and clean the folder name
    final className = folderName
        .split(RegExp(r'[^a-zA-Z0-9]'))
        .where((part) => part.isNotEmpty)
        .map((part) => part[0].toUpperCase() + part.substring(1).toLowerCase())
        .join('');

    return className.isEmpty ? 'Assets' : className;
  }

  /// Get asset name without folder prefix
  String _getAssetNameWithoutPrefix(Asset asset, String directoryPath) {
    final fileName = asset.relativePath.split('/').last;
    return fileName
        .replaceAll('.', '_')
        .replaceAll('-', '_')
        .replaceAll(' ', '_')
        .replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
  }

  /// Generate the main AssetMap class
  String _generateMainAssetClass(
    AssetDirectory rootDirectory,
    List<String> generatedClasses,
  ) {
    final buffer = StringBuffer();

    buffer.writeln('class AssetMap extends PVAssetMap {');

    // Generate static instances for each top-level directory class
    for (final directory in rootDirectory.subdirectories) {
      final className = directory.anonymousClassName;
      final folderName = directory.relativePath.split('/').last;
      final instanceName = _toDartIdentifier(folderName);

      buffer.writeln('  static final $className $instanceName = $className();');
    }

    buffer.writeln('}');
    return buffer.toString();
  }

  /// Generate initialization method that overrides LazyObjectConfig
  String _generateInitializationMethod() {
    final buffer = StringBuffer();

    buffer.writeln('/// Initialize PV Asset System');
    buffer.writeln(
      '/// Call this method once before using any assets to override default loaders',
    );
    buffer.writeln('void initializePVAssets() {');

    if (config.signatures.hasCustomSignatures) {
      buffer.writeln('  // Override LazyObjectConfig with custom loaders');
      buffer.writeln();

      // Generate type map overrides
      bool hasTypeMaps = false;
      for (final signature in config.signatures.signatures.values) {
        if (signature.matchConfig?.extensions != null) {
          if (!hasTypeMaps) {
            buffer.writeln('  // Add custom type mappings');
            hasTypeMaps = true;
          }
          final extensions = signature.matchConfig!.extensions!
              .map((e) => "'$e'")
              .join(', ');
          buffer.writeln(
            '  LazyObjectConfig.defaultTypeMaps["${signature.name}"] = [$extensions];',
          );
        }
      }

      if (hasTypeMaps) {
        buffer.writeln();
      }

      // Generate loader overrides
      bool hasLoaders = false;
      for (final signature in config.signatures.signatures.values) {
        if (signature.loader != null) {
          if (!hasLoaders) {
            buffer.writeln('  // Add custom loaders');
            hasLoaders = true;
          }

          // Use MethodReference file and method properties with alias
          final loader = signature.loader!;
          final alias = PathResolver.generateImportAlias(loader.file);
          buffer.writeln(
            '  LazyObjectConfig.defaultTypeLoaders["${signature.name}"] = $alias.${loader.method};',
          );
        }
      }
    } else {
      buffer.writeln('  // No custom loaders configured');
      buffer.writeln('  // Using default LazyObjectConfig settings');
    }

    buffer.writeln('}');
    return buffer.toString();
  }

  /// Generate method imports for custom loaders using smart path resolution
  Future<List<String>> _generateMethodImports() async {
    final imports = <String>[];
    final importedFiles = <String>{};
    final pathResolver = PathResolver(projectRoot, config.target);

    // Collect unique file names from signature loaders
    for (final signature in config.signatures.signatures.values) {
      if (signature.loader != null) {
        final fileName = signature.loader!.file;
        if (!importedFiles.contains(fileName)) {
          final resolvedPath = await pathResolver.resolveLoaderPath(fileName);
          if (resolvedPath != null) {
            final alias = PathResolver.generateImportAlias(fileName);
            imports.add("import '$resolvedPath' as $alias;");
            importedFiles.add(fileName);
          } else {
            // Fallback or warning for missing loader
            imports.add(
              "// Warning: Could not resolve loader file: $fileName.dart",
            );
          }
        }
      }
    }

    return imports;
  }

  /// Generate initialization code for custom methods
  String _generateCustomMethodInit() {
    if (!config.signatures.hasCustomSignatures) return '';

    final buffer = StringBuffer();

    buffer.writeln('/// Initialize custom asset loading methods');
    buffer.writeln('void initializeCustomAssetLoading() {');
    buffer.writeln('  // Merge custom configurations with defaults');
    buffer.writeln(
      '  LazyObjectConfig.defaultTypeMaps.addAll(CustomLazyObjectConfig.customTypeMaps);',
    );
    buffer.writeln(
      '  LazyObjectConfig.defaultTypeLoaders.addAll(CustomLazyObjectConfig.customTypeLoaders);',
    );
    buffer.writeln('}');

    return buffer.toString();
  }

  /// Generate README documentation for the generated assets
  String generateDocumentation(
    AssetDirectory rootDirectory,
    ScanStatistics stats,
  ) {
    final buffer = StringBuffer();

    buffer.writeln('# Generated Asset Documentation');
    buffer.writeln();
    buffer.writeln(
      'This file contains generated asset mappings for your project.',
    );
    buffer.writeln();

    buffer.writeln('## Statistics');
    buffer.writeln('- **Total Assets**: ${stats.totalAssets}');
    buffer.writeln('- **Total Directories**: ${stats.totalDirectories}');
    buffer.writeln();

    if (stats.signatureCount.isNotEmpty) {
      buffer.writeln('## Assets by Signature');
      for (final entry in stats.signatureCount.entries) {
        buffer.writeln('- **${entry.key}**: ${entry.value} assets');
      }
      buffer.writeln();
    }

    buffer.writeln('## Usage Examples');
    buffer.writeln();

    // Generate usage examples
    for (final directory in rootDirectory.subdirectories) {
      if (directory.assets.isNotEmpty) {
        final exampleAsset = directory.assets.first;
        buffer.writeln('```dart');
        buffer.writeln('// Access asset: ${exampleAsset.relativePath}');

        if (exampleAsset.needsLoadSignature && exampleAsset.signature != null) {
          buffer.writeln(
            'Widget widget = AssetMap.${_toDartIdentifier(directory.relativePath.split('/').first)}.${exampleAsset.dartIdentifier}.value;',
          );
          buffer.writeln(
            '// Uses custom loader for signature: ${exampleAsset.signature}',
          );
        } else {
          buffer.writeln(
            'Widget widget = AssetMap.${_toDartIdentifier(directory.relativePath.split('/').first)}.${exampleAsset.dartIdentifier}.value;',
          );
        }

        buffer.writeln('```');
        buffer.writeln();
        break;
      }
    }

    if (config.signatures.hasCustomSignatures) {
      buffer.writeln('## Custom Signatures');
      buffer.writeln();
      buffer.writeln('This project uses custom asset loading signatures:');

      for (final signature in config.signatures.signatures.values) {
        buffer.writeln('- **${signature.name}**: ');
        if (signature.loader != null) {
          buffer.writeln('  - Loader: `${signature.loader}`');
        }
        if (signature.matchConfig != null) {
          final match = signature.matchConfig!;
          if (match.pathPattern != null) {
            buffer.writeln('  - Path Pattern: `${match.pathPattern}`');
          }
          if (match.extensions != null) {
            buffer.writeln('  - Extensions: ${match.extensions}');
          }
          if (match.customMatcher != null) {
            buffer.writeln('  - Custom Matcher: `${match.customMatcher}`');
          }
        }
      }
      buffer.writeln();
    }

    return buffer.toString();
  }

  /// Convert string to valid Dart identifier
  String _toDartIdentifier(String input) {
    // Remove or replace invalid characters
    String identifier = input
        .replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_')
        .replaceAll(RegExp(r'^[0-9]'), '_');

    // Ensure it's not empty and starts with letter/underscore
    if (identifier.isEmpty || RegExp(r'^[0-9]').hasMatch(identifier)) {
      identifier = '_$identifier';
    }

    return identifier;
  }

  /// Escape string for use in Dart string literals
  String _escapeStringForDart(String input) {
    // Normalize path separators to forward slashes
    String normalized = input.replaceAll('\\', '/');

    // Escape special characters for Dart string literals
    return normalized
        .replaceAll('\\', '\\\\')
        .replaceAll('"', '\\"')
        .replaceAll('\$', '\\\$')
        .replaceAll('\n', '\\n')
        .replaceAll('\r', '\\r')
        .replaceAll('\t', '\\t');
  }

  /// Generate type definition comments for better IDE support
  String _generateTypeComments(Asset asset) {
    final buffer = StringBuffer();

    buffer.write('  /// Asset: ${asset.relativePath}');

    if (asset.signature != null) {
      buffer.write(' (${asset.signature})');
    }

    if (asset.needsLoadSignature) {
      buffer.write(' - Uses custom loader');
    }

    return buffer.toString();
  }

  /// Validate generated code for common issues
  List<String> validateGeneratedCode(AssetDirectory rootDirectory) {
    final errors = <String>[];
    final identifiers = <String>{};

    // Check for duplicate identifiers
    void checkDirectory(AssetDirectory directory) {
      for (final asset in directory.assets) {
        final id = asset.dartIdentifier;
        if (identifiers.contains(id)) {
          errors.add('Duplicate identifier: $id (from ${asset.relativePath})');
        } else {
          identifiers.add(id);
        }
      }

      for (final subdir in directory.subdirectories) {
        checkDirectory(subdir);
      }
    }

    checkDirectory(rootDirectory);

    // Check for reserved Dart keywords
    const reservedWords = [
      'class',
      'const',
      'final',
      'var',
      'void',
      'return',
      'if',
      'else',
    ];
    for (final word in reservedWords) {
      if (identifiers.contains(word)) {
        errors.add('Reserved keyword used as identifier: $word');
      }
    }

    return errors;
  }
}
