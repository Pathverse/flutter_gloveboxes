/// Utilities for code generation
class CodeGenUtils {
  /// Generate a standard file header with metadata
  static String generateFileHeader({
    String? description,
    int? packageCount,
    int? localeCount,
    bool includeDoNotModify = true,
  }) {
    final buffer = StringBuffer();

    if (includeDoNotModify) {
      buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    }
    buffer.writeln('// Generated by pvtro_builder');

    if (description != null) {
      buffer.writeln('// $description');
    }

    if (packageCount != null && localeCount != null) {
      buffer.writeln(
        '// Found $packageCount slang packages with $localeCount unique locales',
      );
    }

    buffer.writeln();
    return buffer.toString();
  }

  /// Generate import statements
  static String generateImports(List<String> imports, {String? groupComment}) {
    if (imports.isEmpty) return '';

    final buffer = StringBuffer();

    if (groupComment != null) {
      buffer.writeln('// $groupComment');
    }

    for (final import in imports) {
      buffer.writeln("import '$import';");
    }
    buffer.writeln();

    return buffer.toString();
  }

  /// Generate a documentation comment
  static String generateDocComment(String comment, {int indent = 0}) {
    final indentStr = ' ' * indent;
    final lines = comment.split('\n');

    if (lines.length == 1) {
      return '$indentStr/// $comment\n';
    }

    final buffer = StringBuffer();
    buffer.writeln('$indentStr/// $comment');
    for (int i = 1; i < lines.length; i++) {
      if (lines[i].trim().isEmpty) {
        buffer.writeln('$indentStr///');
      } else {
        buffer.writeln('$indentStr/// ${lines[i]}');
      }
    }

    return buffer.toString();
  }

  /// Generate an enum with documentation
  static String generateEnum({
    required String enumName,
    required List<EnumValue> values,
    String? documentation,
    int indent = 0,
  }) {
    final indentStr = ' ' * indent;
    final buffer = StringBuffer();

    if (documentation != null) {
      buffer.write(generateDocComment(documentation, indent: indent));
    }

    buffer.writeln('${indentStr}enum $enumName {');

    for (final value in values) {
      if (value.documentation != null) {
        buffer.write(
          generateDocComment(value.documentation!, indent: indent + 2),
        );
      }
      buffer.writeln('$indentStr  ${value.name},');
    }

    buffer.writeln('$indentStr}');

    return buffer.toString();
  }

  /// Generate a switch statement
  static String generateSwitch({
    required String switchExpression,
    required List<SwitchCase> cases,
    String? defaultCase,
    int indent = 0,
  }) {
    final indentStr = ' ' * indent;
    final buffer = StringBuffer();

    buffer.writeln('${indentStr}switch ($switchExpression) {');

    for (final switchCase in cases) {
      for (final pattern in switchCase.patterns) {
        buffer.writeln('$indentStr  case $pattern:');
      }
      buffer.writeln('$indentStr    ${switchCase.body}');
    }

    if (defaultCase != null) {
      buffer.writeln('$indentStr  default:');
      buffer.writeln('$indentStr    $defaultCase');
    }

    buffer.writeln('$indentStr}');

    return buffer.toString();
  }

  /// Generate a method with documentation
  static String generateMethod({
    required String methodName,
    required String returnType,
    required String body,
    List<Parameter> parameters = const [],
    String? documentation,
    bool isStatic = false,
    int indent = 0,
  }) {
    final indentStr = ' ' * indent;
    final buffer = StringBuffer();

    if (documentation != null) {
      buffer.write(generateDocComment(documentation, indent: indent));
    }

    final staticModifier = isStatic ? 'static ' : '';
    final paramStr = parameters.map((p) => '${p.type} ${p.name}').join(', ');

    buffer.writeln(
      '$indentStr$staticModifier$returnType $methodName($paramStr) {',
    );

    // Add body with proper indentation
    final bodyLines = body.split('\n');
    for (final line in bodyLines) {
      if (line.trim().isNotEmpty) {
        buffer.writeln('$indentStr  $line');
      } else {
        buffer.writeln();
      }
    }

    buffer.writeln('$indentStr}');

    return buffer.toString();
  }
}

/// Represents an enum value with optional documentation
class EnumValue {
  final String name;
  final String? documentation;

  EnumValue(this.name, {this.documentation});
}

/// Represents a switch case with patterns and body
class SwitchCase {
  final List<String> patterns;
  final String body;

  SwitchCase(this.patterns, this.body);
}

/// Represents a method parameter
class Parameter {
  final String type;
  final String name;
  final String? defaultValue;

  Parameter(this.type, this.name, {this.defaultValue});
}
